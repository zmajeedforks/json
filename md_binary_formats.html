<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JSON for Modern C++: Binary formats</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mylayout.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JSON for Modern C++
   &#160;<span id="projectnumber">3.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Binary formats </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="binary.png" alt="binary.png"/>
<div class="caption">
conversion between JSON and binary formats</div></div>
<p>Several formats exist that encode JSON values in a binary format to reduce the size of the encoded value as well as the required effort to parse encoded value. The library implements three formats, namely</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7049">CBOR</a> (Concise Binary Object Representation)</li>
<li><a href="https://msgpack.org">MessagePack</a></li>
<li><a href="http://ubjson.org">UBJSON</a> (Universal Binary JSON)</li>
</ul>
<h2>Interface</h2>
<h3>JSON to binary format</h3>
<p>For each format, the <code>to_*</code> functions (i.e., <code>to_cbor</code>, <code>to_msgpack</code>, and <code>to_ubjson</code>) convert a JSON value into the respective binary format. Taking CBOR as example, the concrete prototypes are:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> std::vector&lt;uint8_t&gt; to_cbor(<span class="keyword">const</span> basic_json&amp; j);                    <span class="comment">// 1</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> to_cbor(<span class="keyword">const</span> basic_json&amp; j, detail::output_adapter&lt;uint8_t&gt; o); <span class="comment">// 2</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> to_cbor(<span class="keyword">const</span> basic_json&amp; j, detail::output_adapter&lt;char&gt; o);    <span class="comment">// 3</span></div></div><!-- fragment --><p>The first function creates a byte vector from the given JSON value. The second and third function writes to an output adapter of <code>uint8_t</code> and <code>char</code>, respectively. Output adapters are implemented for strings, output streams, and vectors.</p>
<p>Given a JSON value <code>j</code>, the following calls are possible:</p>
<div class="fragment"><div class="line">std::vector&lt;uint8_t&gt; v;</div><div class="line">v = json::to_cbor(j);   <span class="comment">// 1</span></div><div class="line"></div><div class="line">json::to_cbor(j, v);    <span class="comment">// 2</span></div><div class="line"></div><div class="line">std::string s;</div><div class="line">json::to_cbor(j, s);    <span class="comment">// 3</span></div><div class="line"></div><div class="line">std::ostringstream oss;</div><div class="line">json::to_cbor(j, oss);  <span class="comment">// 3</span></div></div><!-- fragment --><h3>Binary format to JSON</h3>
<p>Likewise, the <code>from_*</code> functions (i.e, <code>from_cbor</code>, <code>from_msgpack</code>, and <code>from_ubjson</code>) convert a binary encoded value into a JSON value. Taking CBOR as example, the concrete prototypes are:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> basic_json from_cbor(detail::input_adapter i, <span class="keyword">const</span> <span class="keywordtype">bool</span> strict = <span class="keyword">true</span>); <span class="comment">// 1</span></div><div class="line"><span class="keyword">static</span> basic_json from_cbor(A1 &amp;&amp; a1, A2 &amp;&amp; a2, <span class="keyword">const</span> <span class="keywordtype">bool</span> strict = <span class="keyword">true</span>);      <span class="comment">// 2</span></div></div><!-- fragment --><p>Both functions read from an input adapter: the first function takes it directly form argument <code>i</code>, whereas the second function creates it from the provided arguments <code>a1</code> and <code>a2</code>. If the optional parameter <code>strict</code> is true, the input must be read completely (or a parse error exception is thrown). If it is false, parsing succeeds even if the input is not completely read.</p>
<p>Input adapters are implemented for input streams, character buffers, string literals, and iterator ranges.</p>
<p>Given several inputs (which we assume to be filled with a CBOR value), the following calls are possible:</p>
<div class="fragment"><div class="line">std::string s;</div><div class="line"><a class="code" href="namespacenlohmann_a2bfd99e845a2e5cd90aeaf1b1431f474.html#a2bfd99e845a2e5cd90aeaf1b1431f474">json</a> j1 = json::from_cbor(s);                         <span class="comment">// 1</span></div><div class="line"></div><div class="line">std::ifstream is(<span class="stringliteral">&quot;somefile.cbor&quot;</span>, std::ios::binary);</div><div class="line"><a class="code" href="namespacenlohmann_a2bfd99e845a2e5cd90aeaf1b1431f474.html#a2bfd99e845a2e5cd90aeaf1b1431f474">json</a> j2 = json::from_cbor(is);                        <span class="comment">// 1</span></div><div class="line"></div><div class="line">std::vector&lt;uint8_t&gt; v;</div><div class="line"><a class="code" href="namespacenlohmann_a2bfd99e845a2e5cd90aeaf1b1431f474.html#a2bfd99e845a2e5cd90aeaf1b1431f474">json</a> j3 = json::from_cbor(v);                         <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* buff;</div><div class="line">std::size_t buff_size;</div><div class="line"><a class="code" href="namespacenlohmann_a2bfd99e845a2e5cd90aeaf1b1431f474.html#a2bfd99e845a2e5cd90aeaf1b1431f474">json</a> j4 = json::from_cbor(buff, buff_size);           <span class="comment">// 2</span></div></div><!-- fragment --><h2>Details</h2>
<h3>CBOR</h3>
<p>The mapping from CBOR to JSON is <b>incomplete</b> in the sense that not all CBOR types can be converted to a JSON value. The following CBOR types are not supported and will yield parse errors (parse_error.112):</p>
<ul>
<li>byte strings (0x40..0x5F)</li>
<li>date/time (0xC0..0xC1)</li>
<li>bignum (0xC2..0xC3)</li>
<li>decimal fraction (0xC4)</li>
<li>bigfloat (0xC5)</li>
<li>tagged items (0xC6..0xD4, 0xD8..0xDB)</li>
<li>expected conversions (0xD5..0xD7)</li>
<li>simple values (0xE0..0xF3, 0xF8)</li>
<li>undefined (0xF7)</li>
</ul>
<p>CBOR further allows map keys of any type, whereas JSON only allows strings as keys in object values. Therefore, CBOR maps with keys other than UTF-8 strings are rejected (parse_error.113).</p>
<p>The mapping from JSON to CBOR is <b>complete</b> in the sense that any JSON value type can be converted to a CBOR value.</p>
<p>If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the dump() function which serializes NaN or Infinity to null.</p>
<p>The following CBOR types are not used in the conversion:</p>
<ul>
<li>byte strings (0x40..0x5F)</li>
<li>UTF-8 strings terminated by "break" (0x7F)</li>
<li>arrays terminated by "break" (0x9F)</li>
<li>maps terminated by "break" (0xBF)</li>
<li>date/time (0xC0..0xC1)</li>
<li>bignum (0xC2..0xC3)</li>
<li>decimal fraction (0xC4)</li>
<li>bigfloat (0xC5)</li>
<li>tagged items (0xC6..0xD4, 0xD8..0xDB)</li>
<li>expected conversions (0xD5..0xD7)</li>
<li>simple values (0xE0..0xF3, 0xF8)</li>
<li>undefined (0xF7)</li>
<li>half and single-precision floats (0xF9-0xFA)</li>
<li>break (0xFF)</li>
</ul>
<h3>MessagePack</h3>
<p>The mapping from MessagePack to JSON is <b>incomplete</b> in the sense that not all MessagePack types can be converted to a JSON value. The following MessagePack types are not supported and will yield parse errors:</p>
<ul>
<li>bin 8 - bin 32 (0xC4..0xC6)</li>
<li>ext 8 - ext 32 (0xC7..0xC9)</li>
<li>fixext 1 - fixext 16 (0xD4..0xD8)</li>
</ul>
<p>The mapping from JSON to MessagePack is <b>complete</b> in the sense that any JSON value type can be converted to a MessagePack value.</p>
<p>The following values can not be converted to a MessagePack value:</p>
<ul>
<li>strings with more than 4294967295 bytes</li>
<li>arrays with more than 4294967295 elements</li>
<li>objects with more than 4294967295 elements</li>
</ul>
<p>The following MessagePack types are not used in the conversion:</p>
<ul>
<li>bin 8 - bin 32 (0xC4..0xC6)</li>
<li>ext 8 - ext 32 (0xC7..0xC9)</li>
<li>float 32 (0xCA)</li>
<li>fixext 1 - fixext 16 (0xD4..0xD8)</li>
</ul>
<p>Any MessagePack output created <code>to_msgpack</code> can be successfully parsed by <code>from_msgpack</code>.</p>
<p>If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the <code>dump()</code> function which serializes NaN or Infinity to <code>null</code>.</p>
<h3>UBJSON</h3>
<p>The mapping from UBJSON to JSON is <b>complete</b> in the sense that any UBJSON value can be converted to a JSON value.</p>
<p>The mapping from JSON to UBJSON is <b>complete</b> in the sense that any JSON value type can be converted to a UBJSON value.</p>
<p>The following values can not be converted to a UBJSON value:</p>
<ul>
<li>strings with more than 9223372036854775807 bytes (theoretical)</li>
<li>unsigned integer numbers above 9223372036854775807</li>
</ul>
<p>The following markers are not used in the conversion:</p>
<ul>
<li><code>Z</code>: no-op values are not created.</li>
<li><code>C</code>: single-byte strings are serialized with S markers.</li>
</ul>
<p>Any UBJSON output created to_ubjson can be successfully parsed by from_ubjson.</p>
<p>If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the <code>dump()</code> function which serializes NaN or Infinity to null.</p>
<p>The optimized formats for containers are supported: Parameter <code>use_size</code> adds size information to the beginning of a container and removes the closing marker. Parameter <code>use_type</code> further checks whether all elements of a container have the same type and adds the type marker to the beginning of the container. The <code>use_type</code> parameter must only be used together with <code>use_size = true</code>. Note that <code>use_size = true</code> alone may result in larger representations - the benefit of this parameter is that the receiving side is immediately informed on the number of elements of the container.</p>
<h2>Size comparison examples</h2>
<p>The following table shows the size compared to the original JSON value for different files from the repository for the different formats.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">format  </th><th class="markdownTableHeadRight">sample.json  </th><th class="markdownTableHeadRight">all_unicode.json  </th><th class="markdownTableHeadRight">floats.json  </th><th class="markdownTableHeadRight">signed_ints.json  </th><th class="markdownTableHeadRight">jeopardy.json  </th><th class="markdownTableHeadRight">canada.json   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">JSON  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">100.00 %   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CBOR  </td><td class="markdownTableBodyRight">87.21 %  </td><td class="markdownTableBodyRight">71.18 %  </td><td class="markdownTableBodyRight">48.20 %  </td><td class="markdownTableBodyRight">44.16 %  </td><td class="markdownTableBodyRight">87.96 %  </td><td class="markdownTableBodyRight">50.53 %   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MessagePack  </td><td class="markdownTableBodyRight">87.16 %  </td><td class="markdownTableBodyRight">71.18 %  </td><td class="markdownTableBodyRight">48.20 %  </td><td class="markdownTableBodyRight">44.16 %  </td><td class="markdownTableBodyRight">87.91 %  </td><td class="markdownTableBodyRight">50.56 %   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">UBJSON unoptimized  </td><td class="markdownTableBodyRight">88.15 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">48.20 %  </td><td class="markdownTableBodyRight">44.16 %  </td><td class="markdownTableBodyRight">96.58 %  </td><td class="markdownTableBodyRight">53.20 %   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">UBJSON size-optimized  </td><td class="markdownTableBodyRight">89.26 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">48.20 %  </td><td class="markdownTableBodyRight">44.16 %  </td><td class="markdownTableBodyRight">97.40 %  </td><td class="markdownTableBodyRight">58.56 %   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">UBJSON format-optimized  </td><td class="markdownTableBodyRight">89.45 %  </td><td class="markdownTableBodyRight">100.00 %  </td><td class="markdownTableBodyRight">42.85 %  </td><td class="markdownTableBodyRight">39.26 %  </td><td class="markdownTableBodyRight">94.96 %  </td><td class="markdownTableBodyRight">55.93 %   </td></tr>
</table>
<p>The results show that there does not exist a "best" encoding. Furthermore, it is not always worthwhile to use UBJSON's optimizations. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 20 2019 00:24:08 for JSON for Modern C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
